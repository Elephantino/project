<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>js</title>
  <link rel="stylesheet" href="../style.css">
</head>

<body>
  <div class="wrapper">



    <header class="page--header">
      <div class="container">
        <div class="header__inner">

          <a href="../index.html">
            <svg width="125px" height="20px">
              <use href="../img/sprite.svg#logo"></use>
            </svg>
          </a>

          <ul class="header-list list-reset">
            <li class="item"><a href="examples.html">examples</a></li>
            <li class="item"><a href="html.html">html</a></li>
            <li class="item"><a href="css.html">css</a></li>
            <li class="item"><a href="js.html">js</a></li>
            <li class="item"><a href="svg.html">svg</a></li>
            <li class="item"><a href="about.html">about</a></li>
          </ul>

        </div>
      </div>
    </header>




    <main class="main">
      <div class="container">
        <div class="main__inner">

          <section class=" layout">

            <div class="menu-on-page">
              <button class="menu-on-page__btn"></button>
              <ol class="layout__tab-list list-reset">

                <li class="layout__tab-item"><a href="#проверки">проверки</a></li>
                <li class="layout__tab-item"><a href="#Преобразования">Преобразования</a></li>
                <li class="layout__tab-item"><a href="#Изменение документа">Изменение документа</a></li>
                <li class="layout__tab-item"><a href="#Стили и классы">Стили и классы</a></li>
                <li class="layout__tab-item"><a href="#export-import">export-import</a></li>
                <li class="layout__tab-item"><a href="#структуры">структуры</a></li>
                <li class="layout__tab-item"><a href="#Логические операторы">Логические операторы</a></li>
                <li class="layout__tab-item"><a href="#циклы">циклы</a></li>
                <li class="layout__tab-item"><a href="#Получение элементов">Получение элементов</a></li>
                <li class="layout__tab-item"><a href="#events">events</a></li>
                <li class="layout__tab-item"><a href="#"></a></li>
                <li class="layout__tab-item"><a href="#"></a></li>
                <li class="layout__tab-item"><a href="#"></a></li>
                <li class="layout__tab-item"><a href="#"></a></li>
                <li class="layout__tab-item"><a href="#"></a></li>

              </ol>
            </div>


            <section class="checks">

              <a name="проверки">
                <h2>Проверки</h2>
              </a>


              <details class="show-piece typeof">
                <summary>typeof -- узнать тип примитивного значения</summary>
                <pre>
  <code>
 console.log(typeof 21); // =&gt; number
 console.log(typeof '21'); // =&gt; string
 console.log(typeof false); // =&gt; boolean
 console.log(typeof {}); // =&gt; object
 console.log(typeof undefined); // =&gt; undefined
 console.log(typeof null); // =&gt; object (признанный баг, который
         не исправляют ради обратной совместимости)
  </code>
</pre>
              </details>

              <details class="show-piece isNaN">
                <summary>isNaN -- является ли значение выражения числом</summary>
                <pre>
  <code>
isNaN(123) // false (число)
  
isNaN("50 рублей") // (не число) 
  </code>
</pre>
                <p>Иногда можно получить такую ошибку JavaScript — NaN — когда значение не является числом (а
                  ожидается
                  число):</p>
                <pre>
  <code>
  let a=8;
  let b="pi";
  let S=a*b; // S=NaN
  </code>
</pre>
                <p>В качестве значения переменной может быть undefined — не определено. Такое случается, когда
                  переменная
                  создана, но значение ей не присвоено:</p>
                <pre>
  <code>
   let b;
   document.write(b); // b=undefined 
  </code>
</pre>
              </details>


              <details class="show-piece">
                <summary>четное или нечетное</summary>
                <pre>
  <code>
const isEven = x =&gt; {
  
  if (x % 2 === 0) {  // If the remainder after dividing by two is 0, return true
    return true;
  }
  return false; // If the number is odd, return false
}

isEven(12);  //true
  </code>
</pre>
              </details>

              <details class="show-piece">
                <summary>matches, closest и contains</summary>

                <div class="matches">
                  <h2>matches</h2>
                  <h3>true / false.</h3>
                  <p>проверить HTML-элемент на соответствие CSS-селектору</p>
                  <div class="matches__inner">
                    <ul class="matches__list">
                      <li>Lorem ipsum dolor sit amet.</li>
                      <li>Lorem ipsum dolor sit amet.</li>
                      <li>Lorem ipsum dolor sit amet.</li>
                      <li>Lorem ipsum dolor sit amet.</li>
                      <li>Lorem ipsum dolor sit amet.</li>
                    </ul>
                  </div>

                </div>
                <div class="closest">
                  <h2>closest</h2>

                </div>
                <div class="contains">
                  <h2>contains</h2>
                </div>

              </details>



            </section>

            <section class="transformation">
              <a name="Преобразования">
                <h2>Преобразования</h2>
              </a>


              <pre>
    <code>
let a = parseInt(prompt("Возраст?", '18'));
let b = Number(prompt("Вesult")); 

x = +x // к числу
x = x + '' // к строке
x = !!x // к булеву типу

x = Number(x) 
x = String(x)
x = Boolean(x)
    </code>
</pre>

              <details class="show-piece join">
                <summary>join - массив в строку</summary>
                <pre>
  <code>
let arr = [1, 2, "str", false];

arr.join(" "); // "1 2 str false" (string)
  </code>
</pre>
              </details>

              <details class="show-piece split">
                <summary>split - строка в массив</summary>
                <pre>
  <code>
let arrTwo = str.split("/"); // ["1", "2", "str", "false"] (array)
  </code>
</pre>
              </details>

              <details class="show-piece toString">
                <summary>toString - объект в строку</summary>
                <pre>
    <code>
obj.toString 
    </code>
</pre>
              </details>

              <details class="show-piece keys-values">
                <summary>keys / values - объект в массив</summary>
                <p>В стандартном конструкторе Object имеются методы keys и values с помощью которых можно
                  трансформировать
                  объект в массив ключей и значений</p>
                <pre>
  <code>
const car = {
  brand: 'Ford',
  color: 'blue'
}

const keys = Object.keys(car); // ['brand', 'color'] 
const values = Object.values(car); // ['Ford', 'blue'] 

  </code>
</pre>
              </details>

              <details class="show-piece nodelist-array">
                <summary>NodeList - в массив </summary>
                <pre>
  <code>
const nodeList = document.querySelectorAll('div');
const result = [];

for (const node of nodeList) {
  result.push(node);
}
  </code>
</pre>
                <p>Также у NodeList есть метод forEach</p>
                <pre>
  <code>
const nodeList = document.querySelectorAll('div');
const result = [];

nodeList.forEach((node) =&gt; {
  result.push(node);
});
  </code>
</pre>
                <p>Array.from();</p>
                <pre>
  <code>
const nodeList = document.querySelectorAll('div');
const result = Array.from(nodeList);
  </code>
</pre>
                <p>spread</p>
                <pre>
  <code>
const divList = document.querySelectorAll('div');
const arr = [...divList];
  </code>
</pre>
              </details>

              <details class="show-piece parseInt">
                <summary>parseInt - строку в целое число</summary>
                <p>преобразует указанную строку в целое число. Если есть второй параметр — система счисления —
                  преобразование происходит по указанному основанию системы счисления (8, 10 или 16):</p>
                <pre>
    <code>
parseInt("435") // 435
parseInt("3.14") // 3
parseInt("-7.875") // -7
parseInt("Вася") // NaN
parseInt("15" ,8) // 13

parseInt - отсекает дробную часть числа.
    </code>
</pre>
              </details>

              <details class="show-piece parseFloat">
                <summary>parseFloat - строку в дробное число</summary>
                <p>преобразует указанную строку в число с плавающей точкой (десятичной):</p>
                <pre>
    <code>
parseFloat ("435") // 435
parseFloat("3.14") // 3.14
parseFloat("-7.875") // -7.875
parseFloat ("Вася") // NaN
parseFloat ("17.5") // 17.5
    </code>
</pre>
              </details>

            </section>

            <section class="transformation-document">

              <a name="Изменение документа">
                <h2>Изменение документа</h2>
              </a>

              <details class="show-piece createElement">
                <summary><code>textContent / innerHTML</code> - получить / добавить просто текст</summary>
                <p><span class="red">Отличие обоих методов от <code>createTextNode</code> в том что эти методы
                    меняют
                    текст в уже
                    существующем элементе в то время как <code>createTextNode</code> создает новый текстовый
                    узел</span>
                </p>

                <p><code>textContent - </code> просто текст из элемента (более предпочтительней потому
                  что
                  не нужно парсить html)</p>
                <p><code>innerHTML - </code> контент вместе с тегами</p>

                <pre>
    <code>
element.textContent = 'Дальше будет &lt;b&gt;интереснее!&lt;/b&gt;';  // Дальше будет &lt;b&gt;интереснее!&lt;/b&gt;
element.innerHTML = 'Дальше будет &lt;b&gt;интереснее!&lt;/b&gt;';    // Дальше будет <b>интереснее!</b>
    </code>
</pre>
              </details>



              <details class="show-piece createElement">
                <summary>Создание узлов - <code>createElement / createTextNode / cloneNode</code></summary>
                <ul>
                  <li><code>document.createElement('tag')</code></li>
                  <li><code>document.createTextNode('value') - схож с textContent</code></li>
                  <li><code>elem.cloneNode(deep / true / false)</code></li>
                </ul>

                <h4>Клонирование узла</h4>
                <p><code>elem.cloneNode(true/false)</code></p>

                <ul>
                  <li><code>deep - </code>true</li>
                  <li><code>true - </code>со всеми атрибутами и дочерними элементами</li>
                  <li><code>false - </code>без дочерних элементов.</li>
                </ul>

                <pre>
    <code>
&lt;div class="alert" id="div"&gt;
  &lt;strong&gt;Всем привет!&lt;/strong&gt; Вы прочитали важное сообщение.
&lt;/div&gt;

let div2 = div.cloneNode(true); // клонировать сообщение
div2.querySelector('strong').innerHTML = 'Всем пока!'; // изменить клонированный элемент

div.after(div2); // показать клонированный элемент после существующего div
    </code>
</pre>

              </details>


              <details class="show-piece">

                <summary>Вставка и удаление элементов -
                  <code>append / prepend / before / after / replaceWith / remove</code>
                </summary>

                <p>Методы node могут вставлять несколько узлов и текстовых фрагментов за один вызов.</p>

                <ul>
                  <li><code>node.append(...nodes or strings) – вставляет в node в конец</code></li>
                  <li><code>node.prepend(...nodes or strings) – вставляет в node в начало</code></li>
                  <li><code>node.before(...nodes or strings) – вставляет прямо перед node</code></li>
                  <li><code>node.after(...nodes or strings) – вставляет сразу после node</code></li>
                  <li><code>node.replaceWith(...nodes or strings) – заменяет node</code></li>
                  <li><code>node.remove() – удаляет node</code></li>
                </ul>

                <pre>
    <code>
    <span class="red">before</span>
&lt;ol id="ol"&gt;
    <span class="red">prepend</span>
  &lt;li&gt;0&lt;/li&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
    <span class="red">append</span>
&lt;/ol&gt;
    <span class="red">after</span>
    </code>
</pre>
              </details>


              <details class="show-piece">
                <summary>Устаревшие методы - <code>appendChild / insertBefore / removeChild / replaceChild</code>
                </summary>
                <p>Все эти методы возвращают node</p>
                <ul>
                  <li><code>parent.appendChild(node)</code></li>
                  <li><code>parent.insertBefore(node, nextSibling)</code></li>
                  <li><code>parent.removeChild(node)</code></li>
                  <li><code>parent.replaceChild(newElem, node)</code></li>
                </ul>
              </details>


              <details class="show-piece insertAdjacent">
                <summary>Вставить фрагмент HTML - <code>insertAdjacent...</code></summary>
                <pre>
    <code>
elem.insertAdjacentHTML('where', html) // вставляет html (вставит теги с содержимым)
elem.insertAdjacentText('where', text) // строка text вставляется «как текст», вместо HTML
elem.insertAdjacentElement('where', elem) // вставляет элемент elem
    </code>
</pre>
                <p>вставляет в зависимости от where:</p>
                <ul>
                  <li><code>beforebegin - </code>вставляет html прямо перед elem</li>
                  <li><code>afterbegin - </code>вставляет html в elem в начало</li>
                  <li><code>beforeend - </code>вставляет html в elem в конец</li>
                  <li><code>afterend - </code>вставляет html сразу после elem</li>
                </ul>

                <p>используют только insertAdjacentHTML, потому что для элементов и текста есть методы
                  append/prepend/before/after – их быстрее написать, и они могут вставлять как узлы, так и текст.
                </p>
                <pre>
  <code>
let parent = document.querySelector(".styleAndClass");

let details = document.createElement('details'); // создаем элемент

details.className = "show-piece"; // добавим класс для стилей

parent.append(details); // добавляем элемент на страницу

//фаршируем внутри наш элемент
details.insertAdjacentHTML('afterbegin', `
&lt;summary&gt;&lt;code&gt;заголовок&lt;/code&gt;&lt;/summary&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;pre&gt;
    &lt;code&gt;
код
    &lt;/code&gt;
  &lt;/pre&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;text&lt;/p&gt;
`);
  </code>
</pre>
              </details>


              <details class="show-piece DocumentFragment">
                <summary>DocumentFragment</summary>
                <p>Специальный DOM-узел, обёртка для передачи списков узлов</p>
                <p>он используется в некоторых других областях, например, для элемента template</p>
              </details>


              <details class="show-piece">
                <summary>document.write</summary>
                <p>работает только до загрузки страницы.</p>
                <p>после того, как страница загружена, он уже непригоден к использованию</p>
              </details>


            </section>

            <section class="styleAndClass"><!-- Стили и классы -->
              <a name="Стили и классы">
                <h2>Стили и классы</h2>
              </a>


              <p>Классы – всегда предпочтительный вариант по сравнению со style. Мы должны манипулировать свойством
                style
                только в том случае, если классы «не могут справиться»</p>

              <pre>
    <code>
let top = /* сложные расчёты */;
let left = /* сложные расчёты */;

elem.style.left = left; // например, '123px', значение вычисляется во время работы скрипта
elem.style.top = top; // например, '456px'
    </code>
</pre>


              <details class="show-piece cssText">
                <summary><code>cssText</code> - полная перезапись стилей</summary>

                <p>оно может как добавить стили к существующим, так и полностью перезаписать их на новые</p>

                <pre>
    <code>
let top = /* сложные расчёты */;
let left = /* сложные расчёты */;

elem.style.cssText = `
  top: ${top};
  left: ${left};
`;
    </code>
</pre>
              </details>

              <details class="show-piece className">
                <summary>className</summary>
                <p>Если мы присваиваем что-то elem.className, то это заменяет всю строку с классами</p>
                <pre>
    <code>
&lt;body class="main page"&gt;

  &lt;script&gt;
    alert(document.body.className); // main page
  &lt;/script&gt;
&lt;/body&gt;
    </code>
</pre>

                <p>Если мы присваиваем что-то elem.className, то это заменяет всю строку с классами.</p>
              </details>

              <details class="show-piece classList">
                <summary><code>classList - add / remove / toggle / contains</code></summary>
                <ul>
                  <li><code>elem.classList.add/remove("class без точки")</code> – добавить/удалить класс</li>
                  <li><code>elem.classList.toggle("class без точки")</code> – добавить класс, если его нет, иначе
                    удалить</li>
                  <li><code>elem.classList.contains("class без точки")</code> – проверка наличия класса, возвращает
                    true/false</li>
                </ul>


                <pre>
    <code>
classList перебираемый, поэтому можно перебрать все классы:

&lt;body class="main page"&gt;

    for (let name of document.body.classList) {
      alert(name); // main, затем page
    }
&lt;/body&gt;
    </code>
</pre>
              </details>

              <details class="show-piece style">
                <summary>style</summary>
                <pre>
    <code>
button.style.MozBorderRadius = '5px';
button.style.WebkitBorderRadius = '5px';

document.body.style.backgroundColor = prompt('background color?', 'green');
    </code>
</pre>
              </details>

              <details class="show-piece">
                <summary>Сброс стилей</summary>
                <pre>
    <code>
document.body.style.display = "none"; // скрыть

setTimeout(() =&lt; document.body.style.display = "", 1000); // возврат к нормальному состоянию
    </code>
</pre>
              </details>

              <details class="show-piece">
                <summary>Получить стили</summary>
                <p><code>getComputedStyle(element, [pseudo])</code></p>


                <ul>
                  <li><code>element - </code>Элемент, значения для которого нужно получить</li>
                  <li><code>pseudo - </code>Указывается, если нужен стиль псевдоэлемента, например ::before. Пустая
                    строка
                    или отсутствие аргумента означают сам элемент.</li>
                </ul>

                <p>getComputedStyle требует полное свойство!
                  Для правильного получения значения нужно указать точное свойство. Например: paddingLeft,
                  marginTop,
                  borderTopWidth. При обращении к сокращённому: padding, margin, border – правильный результат не
                  гарантируется.</p>
              </details>

            </section>

            <section class="export-import"><!-- export-import -->
              <a name="export-import">
                <h2>export-import</h2>
              </a>


              <p><b>import</b> <em>дефолтные через запятую</em><b>,</b> { <em>именованные через запятую</em> }
                откуда
                "./... .js"
              </p>

              <div class="export-import__box">

                <pre><code>
<b>Основной файл</b>
  
          
import del, { sum, show, color } from "./func.js";
        


color(elem);
    
sum(4, 1);
    
show(elem);

del(elem);
    <hr>  
<b>переименование</b>

import del as  delete, { * as <span style="color: red;">name</span> } from "./func.js";
import del теперь delete, { все теперь <span style="color: red;">name</span> } из "./func.js";

функции стали как свойства объекта <span style="color: red;">name</span>
но не все а только те которые мы
объединили в объект <ins> * as name</ins>


<span style="color: red;">name</span>.color(elem);
  
<span style="color: red;">name</span>.sum(4, 1);

<span style="color: red;">name</span>.show(elem);

delete(elem); //не свойсво объекта <span style="color: red;">name</span>
</code></pre>

                <pre><code>
<b>Дополнительный файл</b>
  
  
let sum = function (a, b) { ... }
let show = function (elem) { ... }

export let color = function() { ... }
  
export default function del(elem) { ... }
  


      
объявленный экспорт снизу не перечисляется:  

export { sum, show };
</code></pre>
              </div>
            </section>

            <section class="structures"><!-- structures -->
              <a name="структуры">
                <h2 class="title">структуры</h2>
              </a>


              <details class="show-piece primitives">
                <summary>примитивы</summary>
                <p>Все кроме объекта являются примитивными.</p>
                <p>Примитивы неизменны, строку можно только перезаписать полностью. JavaScript
                  неявно оборачивает примитив в объект его типа, так что на примитивах возможно использовать
                  свойства
                  и
                  методы этих объектов.</p>
                <p>Number, BigInt, String, Boolean, null, undefined, Symbol, Object.</p>
              </details>

              <details class="show-piece string">
                <summary>string</summary>
                <p>Объект класса String</p>
                <p>cтрока - примитив, приметив неизменяем(только заменяем).</p>
                <pre>
    <code>
let str = "Строковой литерал"; //string
let str = new String("Объект класса String"); //object
 
 
let str = "How are you?"; //string
 
   "H  o  w     a  r  e     y  o  u  ?";
    0  1  2  3  4  5  6  7  8  9  10 11
пробел тоже символ по этому у него есть индекс.
    </code>
</pre>
                <p>доступ к символам:</p>
                <pre>
    <code>
let str = "JavaScript";

str[0] // J str[index] -- es5
str.charAt(0) // J
str.at(0) // J -- Array.prototype.at

console.log(str[str.length - 1]); // t
console.log(str.at(-1)); // t
    </code>
</pre>
                <p>charAt() или []</p>
                <pre>
    <code>
если на месте искомой позиции символа нет:
  - charAt() вернет пустую строку ''
  - [] – вернет undefined.
    </code>
</pre>

                <div class="block">
                  <h2>перебор строки</h2>
                  <pre>
    <code>
let str = "Hello";

for(let i of str) {
    console.log(i);
}
  //
    H
    e
    l
    l
    o
     //
    </code>
</pre>
                </div>

                <div class="performance">
                  <h2>Методы String</h2>

                  <ul class="list-reset">
                    <li>at() -- возвращает символ</li>
                    <li>charAt() and slice() возвращает строковые значения на основе индексов</li>
                    <li>indexOf() and lastIndexOf() вернут индексы на основе значений</li>


                    <li>charCodeAt() -- возвращает числовое значение Юникода для символа по индексу</li>
                    <li>codePointAt() -- возвращает неотрицательное целое число, являющееся закодированным в UTF-16
                      значением кодовой точки</li>

                    <li>concat() -- объединяет</li>

                    <li>startsWith() -- начинается ли строка с символов указанных в скобках</li>
                    <li>endsWith() -- заканчивается ли строка символами указанными в скобках</li>

                    <li>includes() -- проверяет, содержит ли строка заданную подстроку</li>
                    <li>indexOf() -- возвращает индекс первого вхождения</li>
                    <li>lastIndexOf() -- возвращает индекс последнего вхождения</li>
                    <li>match()-- возвращает совпадения с регулярным выражением</li>

                    <li>padStart() -- дополняет текущую строку с начала</li>
                    <li>padEnd() -- дополняет текущую строку с конца</li>

                    <li>repeat() -- конструирует и возвращает новую строку</li>

                    <li>replace() -- замена части</li>


                    <li>search() -- возвращает индекс первого сопоставления с регулярным выражением внутри строки.
                    </li>

                    <li>split() -- разбивает объект String на массив строк</li>

                    <li>toLocaleLowerCase() / toLocaleUpperCase() / toLowerCase() / toUpperCase()</li>
                    <li>valueOf() возвращает примитивное значение объекта String.</li>

                    <li>toString() возвращает строку, представляющую объект и делает тоже самое, что и метод
                      String.prototype.valueOf().</li>

                    <li>trim() удаляет пробельные символы с начала и конца строки</li>

                  </ul>

                  <details class="show-piece charAt">
                    <summary>charAt -- возврата символа</summary>
                    <p>метод для возврата символа, используя индекс в качестве параметра</p>
                    <pre>
 <code>
"How are you?".charAt(5); //r
 </code>
</pre>
                  </details>

                  <details class="show-piece indexOf">
                    <summary>indexOf -- поиск подстроки</summary>
                    <p>ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию совпадения,
                      либо -1
                      при отсутствии совпадений.</p>
                    <p>чувствителен к регистру</p>
                    <p>вернет порядковый номер первого символа в экземпляре.</p>
                    <pre>
 <code>
let str = 'Widget with id';
 
alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру
 
alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)
это если не указать второй параметр, если указать индекс
дальше позиции 2 то он найдет другое совпадение
 
Необязательный второй аргумент позволяет начать поиск с
определённой позиции.
str.indexOf("id", 2); // 12
 </code>
</pre>

                    <p>Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив
                      очередную
                      позицию, начинаем
                      новый поиск со следующей:</p>

                    <pre>
 <code>
let str = 'Ослик Иа-Иа посмотрел на виадук';
 
let target = 'Иа'; // цель поиска
 
let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;
 
  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}
 
Тот же алгоритм можно записать и короче:
 
let str = "Ослик Иа-Иа посмотрел на виадук";
let target = "Иа";
 
let pos = -1;
  while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
 </code>
</pre>
                  </details>

                  <details class="show-piece includes">
                    <summary>includes(substr, pos) -- возвращает boolean</summary>
                    <p>возвращает true, если в строке str есть подстрока substr, либо false</p>
                    <p>если нам необходимо проверить, есть ли совпадение, но позиция не нужна</p>
                    <pre>
<code>
alert( "Widget with id".includes("Widget") ); // true
alert( "Hello".includes("Bye") ); // false
 
второй аргумент позволяет начать поиск с определённой позиции
alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
</code>
  </pre>
                  </details>

                </div>

                <div class="performance">
                  <h2>Получение подстроки</h2>
                  <p>В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.</p>

                  <details class="show-piece slice">
                    <summary>slice(start [, end]) -- возвращает часть строки</summary>
                    <pre>
<code>
"How are you?".slice(8, 11); //you
      
            индексы символов:  0 1 2 3 4 5 6 7 8
                              ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
            индексы slice:    0 1 2 3 4 5 6 7 8 9

Если аргумент end отсутствует, slice возвращает символы до конца строки.
</code>
</pre>
                  </details>
                </div>


              </details>

              <details class="show-piece function">
                <summary>function</summary>
                <p>объект класса Function</p>
                <p>Функция – особого типа значение переменной</p>

                <ul>
                  <li>функция возвращает только один результат своей работы</li>
                  <li>после <code>return</code> код не выполняется, происходит выход из функции</li>
                  <li>если в функции нет <code>return</code> то она вернет <code>indefined</code></li>
                </ul>

                <div class="performance">
                  <h3 class="performance__title">Function Declaration - объявление функции</h3>

                  <p>может быть вызвана раньше, чем она объявлена.</p>
                  <p>доступна везде внутри блока в котором находится, но не снаружи него</p>
                  <p>инструкция определяет переменную (имя функции) и назначает ей ссылку на функцию. Объявления
                    функций
                    не
                    являются
                    частью обычной
                    последовательности выполнения программ. Они перемещаются в верхнюю часть своей области
                    видимости.
                  </p>
                  <pre>
    <code>
function sayHi() {
  console.log("Привет");
}
sayHi(); //Привет
    </code>
</pre>

                </div>

                <div class="performance">
                  <h3>Function Expression - функциональное выражение</h3>
                  <p>создаётся, когда выполнение доходит до него.</p>
                  <pre>
    <code>
let sayHi = function() {
   console.log("Привет");
}
sayHi(); //Привет
    </code>
</pre>
                </div>

                <div class="performance">
                  <h3>стрелочные</h3>
                  <pre>
  <code>
(...args) =&gt; expression

(...args) =&gt; { return } если использовать скобки то надо явно указать return

return без следующего за ним выражения приводит к тому что функция возвращает undefined

одна и та же функция:
const square = (x) =&gt; {return x * x};
const square = x =&gt; x * x;
  </code>
</pre>
                </div>
              </details>



              <details class="show-piece constructor">
                <summary>constructor</summary>

                <pre>
  <code>
Свойство <span style="color: #cc4700;">constructor</span> ссылается на функцию-конструктор, которая была использована при создании объекта:
            
&lt;script&gt;
            
let x = new String();
            
if (x.constructor == String)
  document.write("Это объект String");  
else
  document.write("Это не String");  
                        
        // выведет:  Это объект String
            
&lt;/script&gt;
  </code>
</pre>
              </details>




              <details class="show-piece htmlCollection">
                <summary>HTMLCollection</summary>
                <p>объект класса HTMLCollection</p>
                <p>getElementsBy...</p>
                <ul>
                  <li>Динамическая коллекция элементов</li>
                  <li>Не имеет привычных методов массива</li>
                  <li>Хранит только узлы HTML элементов(теги)</li>
                  <li>Обращение к элементам коллекции:
                    <ul>
                      <li>по индексу</li>
                      <li>по имени методом namedItem</li>
                    </ul>
                  </li>
                </ul>

                <p>если возвращенная коллекция динамическая то перебирать ее нужно с конца (страница 274)</p>
              </details>

              <details class="show-piece nodeList">
                <summary>NodeList</summary>
                <p>объект класса NodeList</p>
                <p>querySelectorAll / getElementsByName / childNodes</p>
                <ul>
                  <li>статическая / динамическая коллекция элементов</li>
                  <li>не имеет привычных методов массива</li>
                  <li>хранит любые типы узлов(текстовые узлы и комментарии)</li>
                  <li>обращение к элементам коллекции только по индексу</li>
                </ul>
              </details>

              <details class="show-piece array">
                <summary>array</summary>
                <h2>объект класса Array</h2>
                <ul>
                  <li>списки пронумерованных значений</li>
                  <li>могут содержать данные любого типа</li>
                  <li>многие методы массива будут влиять на исходный массив, а не на его копию</li>
                </ul>
                <pre>
  <code>
const a = []
const a = [1, 2, 3]
const a = Array.of(1, 2, 3)
const a = Array(6).fill(1) // 6 элементов c числом 1
</code>
</pre>
                <h3>Доступ к элементам по индексам arr[index]</h3>
                <pre>
   <code>
let arr = [10, "2", 3, false];
let first = arr[0];
let count = 1;

arr[0] и arr.at(0) оба вернут первый элемент

console.log(arr[3]); // false
console.log(first); // 10
console.log(arr[count]) // "2"
  </code>
</pre>

                <p>При использовании точки слово, стоящее после нее, является точечным именем свойства.</p>
                <p>При использовании квадратных скобок,для получении имени свойства
                  <i>Вычисляется</i> заключенное в скобки выражение.
                </p>
                <p>Если value.x извлекает из значения value свойство с именем x, то
                  value[x] пытается вычислить выражение x и применяет результат, преобразованный в строку, в
                  качестве
                  имени
                  свойства</p>
                <p>По этому если вы знаете что интересующее вас свойство называется color, то пишите сразу
                  value.color
                </p>





                <h3>replacement</h3>
                <pre>
   <code>
arr[0] = 4
console.log(a) //[4, "2", 3, false];
   </code>
</pre>

                <h3>add</h3>
                <pre>
  <code>
a[5] = false;
console.log(arr) //[ 4, "2", 3, false "", false ] // Разреженный массив
  </code>
</pre>

                <h3>Обращение к несуществующему элементу вернет undefined</h3>
                <pre>
   <code>
console.log(arr[7]); // undefined
   </code>
</pre>

                <h2>меняем элементы массива местами</h2>
                <pre>
    <code>
let a = [4, 1, 2, 3];
let swap = a[0];

a[1] = swap; // [1, 4, 2, 3]
    </code>
</pre>
                <p>если сразу записать на первое место значение второго элемента, то мы потеряем значение первого.
                </p>


                <div>
                  <p>matches() //проверка</p>
                  <p>closet() //возвращает</p>
                  <p>contains() //проверка</p>
                </div>

                <details class="show-piece array-clone">
                  <summary>Клонирование массива</summary>
                  <p>В js нет метода для клонирования массивов</p>
                  <p>Этот метод легко сэмулировать, помня, что concat и slice не меняют исходный массив. Достаточно
                    вызвать
                    метод
                    concat без
                    аргументов или метод slice с единственным аргументом равным 0.</p>
                  <pre>
   <code>
let a = [1,2,3];
let b = a.concat();
let c = a.slice(0);

(a + ';' + b + ';' + c); // '1,2,3;1,2,3;1,2,3'

([a == b, a == c, b == c]); // [ false,false,false ]
   </code>
</pre>
                  <p>Если в массиве лежат ссылки на объекты, в том числе ссылки на другие массивы, то в
                    новосозданном
                    массиве будут лежать
                    ссылки на те же самые объекты. Поэтому если вы хотите клонировать многомерный массив, то
                    придётся
                    вручную создавать
                    новый массив, после чего перебрать подмассивы исходного массива и клонировать их в новый.</p>
                  <pre>
   <code>
  Клонируется только массив верхнего уровня:
let a = [
[1,2,3],
[4,5,6],
[7,8,9]
];

let b = a.concat();

a[0][1] // 2
b[0][1] // 2

b[0][1] = 15;
a[0][1] // 15
   </code>
</pre>
                  <pre>
   <code>
  Клонируем вложенные массивы:

let a = [
[1,2,3],
[4,5,6],
[7,8,9]
];

let b = [ ];
  a.forEach(function(subArry) {
  b.push(subArray.concat());
})

a[0][1]; // 2
b[0][1]; // 2

b[0][1] = 15;
a[0][1]; // 15
   </code>
</pre>


                </details>

                <div class="performance">
                  <h3>перебор массива</h3>

                  <h3>for</h3>
                  <pre><code>
let arr = [ "a", "b", "c", "d" ];

for (let <span class="color-red">i</span> = 0; i < arr.length; i++) {                
  console.log(i + " - " + arr[i]);             в цикле for переменная <span class="color-red">i</span> - никак к ключу не 
};                                                относится это просто переменная которая 
          i      arr[i]                              изменяется каждую итерацию цикла,
      // ключ - значение                                в других циклах <span class="color-red">i</span> это ключ/свойство
            0 - a
            1 - b
            2 - c
            3 - d

</code></pre>

                  <h3>for in</h3>
                  <p class="color-red">for in не стоит использовать для перебора массива</p>
                  <pre><code>
let arr = [ "a", "b", "c", "d" ];

for (let <span class="color-red">i</span> <span class="color-light-blue">in</span> arr) {  
  console.log(i + " - " + arr[i]);     на место <span class="color-red">i</span> подставляется ключ/свойство 
};                                           каждую итерацию цикла
          i     arr[i]
     // ключ - значение
           0 - a
           1 - b
           2 - c
           3 - d

</code></pre>

                  <h3>for of</h3>

                  <pre><code>
let arr = [ "a", "b", "c", "d" ];

for (let i <span class="color-red">of</span> arr) { 
  console.log(i)                                    на место <span class="color-red">i</span> подставляется ключ/свойство                      
};                                                        каждую итерацию цикла
      // значения 
            a
            b
            c 
            d





</code></pre>

                  <pre><code>
arr.forEach((e) => console.log(e));  // a b c d

arr.map((e) => console.log(e))  // a b c d // новый массив

</code></pre>



                </div>

                <div class="performance">

                  <h2>Методы массивов</h2>

                  <h2>replace</h2>
                  <p>из числа с запятыми 3,45,666 можем получить 345666 использовав <code>.replace(/,/g " ")</code>
                  </p>

                  <details class="show-piece reverse">
                    <summary>Array.indexOf</summary>
                    Array.indexOf — ищет только 1 символ
                    String.indexOf — может искать строку больше 1 символа
                  </details>

                  <details class="show-piece reverse">
                    <summary>reverse - разворачивает</summary>
                    <p>изменяет исходный массив</p>

                    <pre>
  <code>
let a = [ ];

a[1] = 1;
b[2] = 2;

console.log(a + " : " + [0 in a, 1 in a, 2 in a]); // ,1,2, : false,true,true

a.reverse();

console.log(a + " : " + [0 in a, 1 in a, 2 in a]); // 2,1, : true,true,false
  </code>
</pre>
                  </details>

                  <details class="show-piece sort">
                    <summary>sort - сортирует</summary>
                    <p>изменяет исходный массив</p>
                    <p>принимает единственным аргументом функцию, сравнивающую элементы массива. Если функция
                      сравнения не
                      задана, то элементы
                      сортируются в лексикографическом порядке.</p>
                    <pre>
   <code>
 var a = ['d', 'b', 'a', 'e', 'c'];
 a.sort();
 alert(a); // a,b,c,d,e
   </code>
</pre>
                    <p>без переданной callback -функции, если сортировать числа, sort отсортирует их как строки,
                      а не как
                      числа.</p>
                    <pre>
   <code>
 let a = [4, 2, 10, 5, 30];
 a.sort(); // 10,2,30,4,5
   </code>
</pre>
                    <p>для сортировки чисел необходимо передать методу sort функцию сравнения двух чисел (a - b)
                      / (a + b)
                    </p>
                    <pre>
   <code>
 let arr = [ 3, 22, -10, 1, 7 ]

 без callback - функции
 arr.sort(); // [-10, 1, 22, 3, 7] - сортирует в лексикографическом порядке

 с функцией сравнения
 arr.sort((a-b) =&gt; a - b); // [-10, 1, 3, 7, 22] - сортирует по порядку
   </code>
</pre>
                  </details>

                  <details class="show-piece concat">
                    <summary>concat</summary>
                    <p>создаёт копию исходного массива, добавляя к нему переданные аргументы</p>
                    <pre>
   <code>
 Array.prototype.toString = function() {
   return '[' + this.join(,) + ']';
 };


 let a = [1,2,3];

 a.concat(4,5,6); //[1,2,3,4,5,6]

 a.concat([4,5],[6]); //[1,2,3,4,5,6]
   </code>
</pre>
                    <p>Однако дальше одного уровня concat аргументы-массивы не разворачивает</p>
                    <pre>
   <code>
 a.concat([4, [5], 6]); //[1,2,3,4,[5],6]
   </code>
</pre>
                    <p>пропуски как из исходного массива, так и из массивов-аргументов, сохраняются</p>
                    <pre>
   <code>
 let a = [1, , 3];

 console.log(a.concat([4, , 6])); // [1, , 3, 4, , 6]
   </code>
</pre>
                  </details>

                  <details class="show-piece slice">
                    <summary>slice - возвращает подмассив исходного массива</summary>
                    <p>slice(begin[, end])</p>
                    <p>возвращает подмассив исходного массива, начиная с индекса begin и заканчивая индексом end
                      - 1.</p>
                    <p>метод массива с помощью которого можно получить копию части или всего массива</p>
                    <p>Чтобы легче запомнить такую странную нумерацию, лучше считать, что передаются индексы не
                      элементов,
                      а "межэлементного пространства".</p>
                    <pre>
   <code>
 индексы элементов: 0 1 2 3 4 5 6 7 8
                   ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
 индексы slice:    0 1 2 3 4 5 6 7 8 9
   </code>
</pre>
                    <p>становится понятно, что ar.slice(0, 1) вернёт только нулевой элемент, а slice(5, 9) — с
                      пятого по
                      восьмой элементы.</p>
                    <pre>
   <code>
let arr = [0, 1, 2, 3, 4, 5];

arr.slice(0, 2); // 0,1
arr.slice(4, 5); // 4
   </code>
</pre>
                    <p>Если второй аргумент является отрицательным числом, то отсчёт второго индекса идёт с конца
                      массива.
                    </p>
                    <pre>
  <code>
arr.slice(0, -2); // 0,1,2,3 
  </code>
</pre>
                    <p>Если же второй аргумент не передан вообще, то возвращается копия массива от begin до
                      конца.</p>
                    <pre>
   <code>
arr.slice(3); // 3,4,5
   </code>
</pre>
                  </details>

                </div>


              </details>

              <details class="show-piece object">
                <summary>object</summary>

                <div class="performance">
                  <p>рассматривать только свойства самого объекта, а не его прототипов
                    getOwnPropertyNames(), hasOwnProperty(), propertyIsEnumerable.</p>
                </div>

                <p>Объекты для хранения именованных коллекций</p>
                <p>Объекты – это ссылочный тип, когда вы присваиваете объект переменной, вы присваиваете ей не сам
                  этот
                  объект, а ссылку на него, которая указывает на то место в памяти компьютера, где он находится.</p>
                <pre>
<code>
const person = {
name: 'Игорь',      // свойство : значение
  getFullName() {   // метод
    return `${this.name}`
  },
}
 </code>
</pre>

                <div class="performance">
                  <h3>свойства</h3>
                  <ul>
                    <li>свойства это пары ключ: значение</li>
                    <li>свойства объекта неявно имеют строковый тип</li>
                  </ul>
                  <h3>методы</h3>
                  <ul>
                    <li>Методы – это свойства, у которых значение является функцией (поведение объекта)</li>
                  </ul>
                </div>

                <div class="performance">
                  <h3>имена свойств в объекте не явно являются строками.</h3>
                  <p>Их можно не заключать в кавычки, это допустимо только если они составлены по правилам
                    именования
                    переменных
                  </p>
                  <pre>
 <code>
{
  '': 1, // имя является пустой строкой
  'author of post': 'Алексей', // имя состоит из нескольких слов
}
 </code>
</pre>
                </div>

                <div class="performance">
                  <h3>Обращение к свойствам</h3>
                  <pre>
 <code>
через точку:
person.firstName;
 
через квадратные скобки, ключ в этом случае нужно указывать в виде строки:
person['name'];
 
 
разница в том что через . мы не можем обратиться к нестандартному свойству, 
например которое состоит из двух слов или имеет тип nember:
 
person["new prop"] = "bateman";

obj[3] 
 </code>
</pre>
                </div>

                <div class="performance">
                  <h3>обращение к методам</h3>
                  <pre>
  <code>
const getName = person.getFullName();
 
getName;
person.getFullName();
person['getFullName']();
  </code>
</pre>
                </div>

                <div class="performance">
                  <h3>добавление свойств</h3>
                  <pre>
  <code>
person.age= 18;
person["last name"] = "Рыбинский";
person.children = [
  {
    name: 'Алиса',
    age: 8
  },
  {
    name: 'Виктор',
    age: 14
  }
];
  </code>
</pre>
                </div>

                <div class="performance">
                  <h3>изменим значения свойств</h3>
                  <pre>
  <code>
person.name= 'Иван';
person["new prop"] = "money";
  </code>
</pre>
                </div>

                <div class="performance">
                  <h3>Удаление свойств</h3>
                  <pre>
  <code>
delete person.age;
  </code>
</pre>
                </div>

                <div class="performance">
                  <h3>Проверить наличия ключа</h3>
                  <pre>
  <code>
'name' in person // true
'middleName' in person // false
  </code>
</pre>
                </div>

                <div class="performance">
                  <h3>перебор объекта</h3>



                  <h3>for</h3>

                  <pre><code>
const person = {        
  name: "Igor",                   Object.keys(obj) свойства
  age: 28,                        Object.values(obj) значения
  city: "Bratsk",                 Object.entries(obj) весь объект
  hobby: "programmer", 
};

for (let <span class="color-red">i</span> = 0; i < <span class="color-light-blue">Object.keys(person)</span>.length; i++) {
  console.log(<span class="color-light-blue">Object.keys(person)</span>[<span class="color-red">i</span>] + " - " + <span class="color-light-blue">Object.values(person)</span>[<span class="color-red">i</span>]);
}    
     name - Igor
     age - 28
     city - Bratsk
     hobby - programmer

</code></pre>

                  <h3>for in</h3>

                  <pre><code>
const person = {
  name: "Igor",
  age: 28,                            в цикле for in 
  city: "Bratsk",                     на место <span class="color-red">i</span>
  hobby: "programmer",                подставляется ключ/свойство
};                                    каждую итерацию цикла


for (let <span class="color-red">i</span> <span class="color-light-blue">in</span> person) {
  console.log(<span class="color-red">i</span> + "-" + person[<span class="color-red">i</span>])    person[<span class="color-red">i</span>]
}                                 
      name - Igor                     person.name
      age - 28                        person.age
      city - Bratsk                   person.city
      hobby - programmer              person.hobby 

</code></pre>

                  <h3>for of</h3>

                  <pre><code>
по дефолту не удобно перебирать object с for of
потому что object не итерируемый по умолчанию

const person = {             
  name: "Igor",                 
  age: 28, 
  city: "Bratsk", 
  hobby: "programmer", 
};

              массив ключей объекта                        массив значений объекта
for (let i <span class="color-red">of</span> <span class="color-light-blue">Object.<span class="color-red">keys</span>(person)</span>) {   |     for (let i <span class="color-red">of</span> <span class="color-light-blue">Object.<span class="color-red">values</span>(person)</span>) {
  console.log(i);                      |       console.log(i);
}                                      |     }  
        // name                        |          // Igor
           age                         |             28
           city                        |             Bratsk
           hobby                       |             programmer

</code></pre>

                  <h3>forEach</h3>

                  <pre>
  <code>
Object.keys(car).forEach((key) =&gt; {
  console.log(`${key}: ${car[key]}`);
});
  </code>
</pre>
                </div>

                <div class="performance">
                  <h3>Если нужно перебрать только значения, то так:</h3>
                  <pre>
  <code>
Object.values(car).forEach((value) =&gt; {
  console.log(value);
});
  </code>
</pre>
                </div>

                <div class="performance">
                  <h3>keys / values / entries</h3>
                  <pre><code>
const person = {
  name: "Igor",
  lastName: "Rybinsky",
  age: 28,
  city: "Bratsk"
}

Object.keys(obj);    // массив имен объекта
Object.values(obj);  // массив значений объекта
Object.entries(obj); // массив массивов [имя свойства, значение свойства]


console.log(Object.keys(person));    // [ 'name', 'lastName', 'age', 'city' ]
console.log(Object.values(person));  // [ 'Igor', 'Rybinsky', 28, 'Bratsk' ]
console.log(Object.entries(person)); // [ ['name', 'Igor'], ['lastName', 'Rybinsky'], ['age', 28], ['city', 'Bratsk'] ]


</code></pre>
                </div>



                <div class="performance">
                  <h2>методы объектов</h2>
                  <p>delete key — удалит значение</p>
                  <p>key in obj — проверка наличия ключа</p>
                  <p>obj.keys — вернет массив ключей</p>
                  <p>obj.assign — копирует все свойства</p>
                </div>

                <div class="performance">
                  <details class="show-piece object-clone">
                    <summary>Копирование объектов</summary>
                    <p>Переменная, содержащая объект на самом деле содержит не сам объект, а только ссылку на него.
                      При
                      копировании объектов в отличие от значений примитивных типов происходит передача ссылки.</p>
                    <pre>
  <code>
const student1 = { name: 'Carl' };
const student2 = student1;

Теперь student1 и student2 содержат ссылки, 
указывающие на один и тот же объект.

student2.name = 'Nelly';
console.log(student1.name); // Nelly
 </code>
</pre>
                    <p>А что если нам необходимо скопировать не саму ссылку, а создать новый объект с такими же
                      свойствами?
                    </p>
                    <pre>
 <code>
const student3 = {};
for (const key in student1) {
  student3[key] = student1[key];
}

student3 содержит клон объекта student1
student3.name = 'Thyra';
в student1 значение name осталось прежним
console.log(student1.name); // Nelly
 </code>
</pre>

                    <h3>Другой способ скопировать свойства:</h3>
                    <pre>
 <code>
const student4 = Object.assign({}, student1);
 </code>
</pre>

                    <p>Object.assign() позволяет скопировать свойства из множества объектов.</p>
                    <pre>
 <code>
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
console.log(target); // {a: 1, b: 2, c: 3}
 </code>
</pre>

                    <h2>Сравнение объектов</h2>
                    <pre>
 <code>
let objA = {};
let objB = objA;
let objC = {};

console.log( objA === objB ); // true, т.к. переменные содержат одну и ту же ссылку
console.log( objA === objC ); // false, т.к. переменные содержат разные ссылки (оба объекта пусты, но это разные объекты)
 </code>
</pre>
                  </details>

                  <details class="show-piece">
                    <summary>Вычисляемые свойства</summary>
                    <p>В JavaScript имя свойства может быть вычисляемым. То есть для задания имени можно
                      использовать
                      выражение, результат вычисления которого и будет это имя. Указывать вычисляемое свойство
                      необходимо
                      в
                      квадратных скобках [ ]:</p>
                    <pre>
  <code>
const key = 'url';
const app = {
  name: 'Yandex',
  [key]: 'https://yandex.ru/', // имя свойства будет взято из переменной key
};
console.log(app.url); // 'https://yandex.ru/'
 </code>
</pre>

                    <h3>метод с более сложным выражением:</h3>
                    <pre>
  <code>
const key = 'url';
const app = {
  name: 'Yandex',
  [key]: 'https://yandex.ru/',
  ['get' + key.toUpperCase()]() {
    return this[key];
  }
};
console.log(app.getURL()); // 'https://yandex.ru/'
 </code>
</pre>
                  </details>

                  <details class="show-piece object-properties">
                    <summary>Свойства объектов и их конфигурация</summary>
                    <a href="https://itchief.ru/javascript/objects" target="_blank" rel="noopener noreferrer">источник
                      https://itchief.ru/javascript/objects</a>

                    <p>До этого времени мы рассматривали свойства как пары «ключ: значение».</p>
                    <p>Но свойство кроме значения (value) имеет специальные флаги:</p>
                    <ul>
                      <li>writable – доступно ли свойство для изменения;</li>
                      <li>enumerable – доступно ли свойство для перебора в циклах;</li>
                      <li>configurable – доступно ли свойство для настройки и удаления.</li>
                    </ul>


                  </details>
                </div>




              </details>

              <details class="show-piece map">
                <summary>map</summary>
              </details>

              <details class="show-piece set">
                <summary>set</summary>
              </details>

            </section>

            <section class="logical-operators"><!-- logical-operators -->

              <a name="Логические операторы">
                <h2>Логические операторы</h2>
              </a>

              <details class="show-piece">
                <summary><code>?</code> -- если условие истинно, возвращается значение1, в противном случае –
                  значение2</summary>
                <p>имеет три аргумента</p>
                <pre>
  <code>
let result = условие ? значение1 : значение2;
  </code>
</pre>
                <p>Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае –
                  значение2.</p>

                <pre>
  <code>
let accessAllowed = (age &gt; 18) ? true : false;
  </code>
</pre>
                <p>Технически, мы можем опустить круглые скобки вокруг age &gt; 18. Оператор вопросительного знака
                  имеет
                  низкий
                  приоритет,
                  поэтому он выполняется после сравнения &gt;.</p>
                <pre>
  <code>
let accessAllowed = age &gt; 18 ? true : false;
  </code>
</pre>

                <p>обычная последовательная проверка</p>
                <pre>
  <code>
let age = prompt('Возраст?', 18);

let message = (age &lt; 3) ? 'Здравствуй, малыш!' : 
              (age &lt; 18) ? 'Привет!' : 
              (age &lt; 100) ? 'Здравствуйте!' : 'Какой необычный возраст!' ; 

alert( message );     
  </code>
</pre>


                <pre>
  <code>
Вот как это выглядит при использовании if..else:

if (age &lt; 3) { 
  message='Здравствуй, малыш!' ; 
} else if (age &lt; 18) { 
  message='Привет!' ; 
} else if (age &lt; 100) {
  message='Здравствуйте!' ; 
} else { 
  message='Какой необычный возраст!' ; 
}
  </code>
</pre>

              </details>

              <details class="show-piece">
                <summary><code>|| - или</code> -- возвращает первое истинное значение или последнее</summary>
                <pre>
  <code>
result = a || b; //если первый операнд вернет true то второй не вычисляется
  </code>
</pre>
                <p>Существует всего четыре возможные логические комбинации:</p>
                <pre>
  <code>
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
  </code>
</pre>
                <p>Если значение не логического типа, то оно к нему приводится в целях вычислений.</p>
                <pre>
  <code>
    цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

let currentUser = null;
let defaultUser = "John";

let name = currentUser || defaultUser || "unnamed";

alert( name ); // выбирается "John" – первое истинное значение

Если бы и currentUser, и defaultUser были ложными, в качестве результата мы бы наблюдали "unnamed".
  </code>
</pre>

                <p>ИЛИ || вычисляет слева направо. Вычисление останавливается при достижении первого истинного
                  значения.
                  Этот
                  процесс
                  называется «сокращённым вычислением», поскольку второй операнд вычисляется только в том случае,
                  если
                  первого
                  недостаточно для вычисления всего выражения.</p>
                <pre>
  <code>
let x;

true || (x = 1);

alert(x); // undefined, потому что (x = 1) не вычисляется

Если бы первый аргумент имел значение false, то || приступил бы к вычислению второго и выполнил операцию присваивания:

let x;

false || (x = 1);

alert(x); // 1


этот вариант использования || является "аналогом if". Первый операнд преобразуется в логический. Если он оказывается
ложным, начинается вычисление второго.
  </code>
</pre>
              </details>





              <details class="show-piece">
                <summary><code>&& - и</code> -- находит первое ложное значение</summary>

                <p>возвращает true, если оба аргумента истинны, а иначе – false</p>
                <pre>
  <code>
result = a && b; 

alert( true && true ); // true
alert( false && true ); // false
alert( true && false ); // false
alert( false && false ); // false
  </code>
</pre>

                <p>Если все операнды были истинными, возвращается последний.</p>
                <p>Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.</p>
                <pre>
  <code>
    Если первый операнд ложный, && возвращает его. 
          Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0

alert( 1 && 2 && null && 3 ); // null

alert( 1 && 2 && 3 ); // 3
  </code>
</pre>

              </details>





              <details class="show-piece">
                <summary><code></code></summary>

              </details>




              <details class="show-piece">
                <summary><code></code></summary>

              </details>



            </section>

            <section class="js__cycles">
              <a name="циклы">
                <h2 class="title">циклы</h2>
              </a>

              <p><b>for of --- snring, array, nodelist, map, set и т.д.</b></p>
              <p><b>for of --- object</b></p>
              <p><b>for --- свойства / значения</b></p>
              <p>for...in обход перечисляемых свойств объекта осуществляется в произвольном порядке.</p>
              <p>for...of обход происходит в соответствии с тем, какой порядок определён в итерируемом объекте</p>

              <p>for и for in вам нужно использовать конструкцию arr [index]:</p>
              <p>forEach() и for of, вы сразу получаете доступ к самому элементу массива. С forEach() вы можете так
                же
                получить
                индекс массива, с for of индекс не доступен.</p>
              <p>проходит объект в произвольном порядке(порядок сверху в низ не горантирован)</p>




              <div class="performance">
                <h2>for</h2>
                <p>пройти n раз свойства или значения</p>

                <pre>
 <code>
for (let i = 0; i &lt; arr.length; i++) {             let i = 0;
  console.log(i); //ключи                i никакого отношения к индексам не имеет
  console.log(arr[i]); //значения         это обычная переменная котрая изменяется 
}                                             каждую итерацию i++
 </code>
</pre>




                <p>перебрать что то в обратном порядке:</p>
                <pre><code>
for (let i = items.length - 1; i > = 0; i -= 1) { ... }

</code></pre>
              </div>



              <div class="performance">

                <h2>for in -- для перебора свойств объекта</h2>
                <p>for...in -- пройти в цикле по перечисляемым свойствам объекта и свойствам из прототипа.</p>
                <p>Перечисляемые свойства – это свойства, которые разработчик добавляет объекту.</p>
                <p>Встроенные свойства, например length у массива, не обходятся в цикле если им не указан метод. Для
                  изменения
                  значений дескрипторов применяется статический метод Object.defineProperty()</p>

                <pre><code>
const person = {
  name: "Igor",
  age: 28,                            в цикле for in 
  city: "Bratsk",                     на место <span class="color-red">i</span>
  hobby: "programmer",                подставляется ключ/свойство
};                                    каждую итерацию цикла


for (let <span class="color-red">i</span> <span class="color-light-blue">in</span> person) {
  console.log(<span class="color-red">i</span> + "-" + person[<span class="color-red">i</span>])    person[<span class="color-red">i</span>]
}                                 
      name - Igor                     person.name
      age - 28                        person.age
      city - Bratsk                   person.city
      hobby - programmer              person.hobby  
                                                                               
</code></pre>




                <h3 class="color-red">for in не стоит использовать для перебора массива:</h3>
                <p>Нет гарантии, что for...in будет возвращать индексы в конкретном порядке. </p>
                <p>Числовые свойства будут перечисляться в отсортированном порядке по возрастанию</p>


                <pre><code>
let arr = [ "a", "b", "c", "d" ];    
                                        <span class="color-red">не перебирайте массивы с for in</span>
for (let <span class="color-red">i</span> <span class="color-light-blue">in</span> arr) {      
  console.log(<span class="color-red">i</span> + " - " + arr[<span class="color-red">i</span>]);      
};                                            
          <span class="color-red">i</span>     arr[<span class="color-red">i</span>]
     // ключ - значение
           0 - a
           1 - b
           2 - c
           3 - d

</code></pre>


              </div>

              <div class="performance">

                <h2>for of -- обход итерируемых объектов</h2>

                <p><b>snring, array, nodelist, map, set и т.д.</b></p>
                <p>почти то же что и forEach.</p>
                <p>в отличие от forEach(), он работает с break, continue и return.</p>

                <p>в отличии от for in порядок перебора объекта гарантирован</p>
                <pre>
  <code>
let arr = [ "a", "b", "c", "d" ];        for of работает сразу со значениями
                                             к индексам доступа нет
for (let i <span class="color-red">of</span> arr) { -- i значение массива arr
  console.log(i)                                                          
};                                                        
      // значения 
            a
            b
            c 
            d
  </code>
</pre>

                <h4>перебор object</h4>
                <pre><code>
по дефолту не удобно перебирать object с for of
потому что object не итерируемый по умолчанию

const person = {             
  name: "Igor",                 
  age: 28, 
  city: "Bratsk", 
  hobby: "programmer", 
};

              массив ключей объекта                        массив значений объекта
for (let i <span class="color-red">of</span> <span class="color-light-blue">Object.<span class="color-red">keys</span>(person)</span>) {   |     for (let i <span class="color-red">of</span> <span class="color-light-blue">Object.<span class="color-red">values</span>(person)</span>) {
  console.log(i);                      |       console.log(i);
}                                      |     }  
        // name                        |          // Igor
           age                         |             28
           city                        |             Bratsk
           hobby                       |             programmer

 </code>
</pre>


              </div>

            </section>

            <section class=" getting-elements">
              <a name="Получение элементов">
                <h2>Получение элементов</h2>
              </a>


              <p> Почти все методы возвращают коллекции элементов схожих с массивом
                но это объекты классов: Array, NodeList, HTMLCollection и т.д.
                к которым нужно обращаться по индексу <span class="color-yellow">arr.[0]/[1]/[2]</span></p>


              <pre>
  <code>
<span class="color-red-light">element</span>        
   
let e = document.<span class="color-blue">querySelector</span>('#nav &gt; ul.menu__list &gt; li[name="li"] + li');
console.log(e); <span class="color-yellow">// element</span>
   
let eId = document.<span class="color-red-light">getElementById</span>('menu__item-3');
console.log(eId);  <span class="color-yellow">// element</span>
   
   
<span class="color-red-light">NodeList</span> - статическая коллекция элементов  
   
let eAll = document.<span class="color-blue">querySelectorAll</span>('li');
console.log(eAll); <span class="color-yellow">// NodeList</span>
console.log(eAll<span class="color-yellow">[0]</span>); <span class="color-yellow">// element</span>
   
let eName = document.<span class="color-red-light">getElementsByName</span>('li'); //динамическая коллекция 
console.log(eName); <span class="color-yellow">// NodeList</span>
console.log(eName<span class="color-yellow">[1]</span>);<span class="color-yellow">// element</span> 
   
let e = list.<span class="color-blue-light">childNodes</span>; //динамическая коллекция
  хранит в себе псевдомассив дочерних узлов 
  элемента (теги, комментарии и текстовые узлы).
   
   
<span class="color-red-light">HTMLCollection</span> - динамическая коллекция элементов
                        
let eTag = document.<span class="color-red-light">getElementsByTagName</span>('li');
console.log(eTag);   <span class="color-yellow">// HTMLCollection</span>
console.log(eTag<span class="color-yellow">[2]</span>);  <span class="color-yellow">// element</span> 
   
let eClass = document.<span class="color-red-light">getElementsByClassName</span>('menu__item');
console.log(eClass); <span class="color-yellow">// HTMLCollection</span>  
console.log(eClass<span class="color-yellow">[3]</span>);   <span class="color-yellow"> // element </span> 
      </code>
   </pre>
            </section>

            <section class="events">
              <a name="events">
                <h2>events</h2>
              </a>


              <a href="https://www.youtube.com/watch?v=bWCzbR5DvCo&t=908s" target="_blank"
                rel="noopener noreferrer">источник</a>

              <p>каждое событие имеет свой объект свойств с которыми можно взаимодействовать.</p>
              <pre><code>
clientX : 273
clientY : 508
offsetX : 100
offsetY : 77

code : "KeyS"
composed : true
ctrlKey : false
currentTarget : null
defaultPrevented : false
key : "s"
</code></pre>
              <p>их можно вытащить при помощи event</p>
              <p>какое событие будет указано такой объект и выдаст консоль со всеми свойствами этого события</p>

              <pre><code>
document.onmouseleave = (event) => {
  console.log(event);
}

document.onmousemove = (event) => {
  console.log(event);
}

document.onkeydown = (event) => {
  console.log(event);
}


document.onclick = (event) => {
  console.log(event);         //все детали события (и список всех событий)
  console.log(event.type);    //тип события
  console.log(event.target);  //объект на котором сработало событие(всплытие/погружение)
  console.log(event.currentTarget); //объект которому назначен обработчик
  
  console.log(event.offsetX);
  console.log(event.offsetY);
}
  </code>
</pre>


              <h3>Отловить нажатую кнопку мыши</h3>

              <pre>
  <code>
    .which возвращает номер кнопки

document.addEventListener("mousedown", function(event) {
  console.log(`нажата кнопка ${event.which}`);
})

document.addEventListener("mouseup", function (event) {
  console.log(`отпущена кнопка ${event.which}`);
})

document.addEventListener("click", function (event) {
  console.log(`нажата основная кнопка ${event.which}`);
})
  </code>
</pre>


              <article>
                <hgroup>
                  <h2>События форм</h2>
                  <h2>oninput</h2>


                  <a name="oninput">
                    <p>получить данные из поля ввода без отправки формы</p>
                  </a>

                  <p>Мы уже умеем получать <a href="https://htmlacademy.ru/courses/343/run/15">данные из поля
                      ввода</a>, но
                    только
                    после того, как форма была отправлена. Сейчас же нам нужно оценить
                    длину комментария ещё до отправки. Как быть? Воспользуемся обработчиком событий oninput (в
                    переводе с
                    английского это
                    означает «при вводе»). Инструкции внутри обработчика oninput выполняются каждый раз, когда
                    значение в
                    поле ввода
                    меняется. Например:</p>
                  <pre>
  <code>
          Найдём поле ввода
let textarea = document.querySelector('textarea');

          Добавим обработчик событий
textarea.oninput = function () {
          Выведем данные из поля ввода
  console.log(textarea.value);
};
  </code>
</pre>

                  <p>Благодаря обработчику событий oninput мы можем получить текст комментария ещё до того, как
                    пользователь
                    его
                    отправит.</p>


                  <form action="#">

                    <textarea class="first-textarea" name="first-textarea" cols="30" rows="5"
                      id="first-textarea"></textarea>

                    <span class="output-count">использовано
                      <output class="first-output" for="first-textarea">0</output>/10 символов
                    </span>

                    <button class="first-button" type="button">button</button>

                  </form>

                </hgroup>


                <h3>виды событий</h3>

                <h4>простые:</h4>
                <ul>
                  <li><code>mousedown / mouseup -- </code>нажата / отпущена</li>
                  <li>
                    <code>mouseover / mouseout -- </code>курсор появляется над элементом / уходит с него
                  </li>
                  <li>
                    <code>mousemove -- </code>каждое движение над элементом генерирует событие
                  </li>
                  <li>
                    <code>contentmenu -- </code>нажатие правой клавишей миши(и клавиатурой вызывается)
                  </li>
                </ul>

                <h4>контекстные:</h4>
                <ul>
                  <li><code>click -- </code>Вызывается при mousedown, а затем mouseup над одним и тем же элементом
                  </li>
                  <li><code>dblclick -- </code>двойной <code>click</code> над одним и тем же элементом</li>
                </ul>






              </article>


              <ul class="mouseEvent__list">

                <li class="scroll">
                  <h3>scroll</h3>
                  <p>результат в консоли</p>

                  <p>прокрутку нельзя отменить используя event.preventDefault(отменяет действие по
                    умолчанию); потому
                    что метод сработает уже после того как скролл произойдет</p>

                </li>

                <li class="mousemove">
                  <h4>mousemove</h4>
                  <p>Вызывается при каждом движении мыши над элементом</p>
                  <div class="mousemove__hover example">
                    <h4>mousemove</h4>
                    <p>output</p>
                  </div>
                </li>

                <li class="mouse-over-out">

                  <h4>mouseover / mouseout</h4>

                  <p>реагируют на дочерние компоненты элемента</p>
                  <p>реагируют они на них потому что они оба всплывают</p>
                  <p>Оба имеют <code>.relatedTarget</code></p>

                  <h5>mouseover</h5>

                  <p><code>event.target - </code>элемент на который курсор пришел</p>
                  <p><code>event.relatedTarget - </code>элемент с которого курсор пришел</p>

                  <h5>mouseout</h5>

                  <p>для него все наоборот</p>
                  <p><code>event.target - </code>элемент с которого курсор пришел</p>
                  <p><code>event.relatedTarget - </code>элемент на который курсор пришел</p>

                  <div class="mouse-over-out__hover example">
                    <h4>mouseout</h4>
                    <h4>mouseover</h4>
                    <p>реагируют на дочерние компоненты элемента</p>
                  </div>

                <li class="mouse-enter-leave">

                  <h4>mouseenter / mouseleave</h4>
                  <p>не реагируют на дочерние компоненты элементы</p>
                  <p>не реагируют потому что они не всплывают</p>

                  <div class="mouse-enter-leave__hover example">
                    <h4>mouseenter</h4>
                    <h4>mouseleave</h4>
                    <p>не реагируют на дочерние компоненты элементы</p>
                  </div>

                </li>


                <h3>пример реагирования на потомков</h3>

                <p>переход курсором на потомков чувствуется</p>

                <h4>сделан на делегировании событий</h4>

                <div class="mouse-over-out__hover-grid">
                  <span>1</span>
                  <span>2</span>
                  <span>3</span>
                  <span>4</span>
                  <span>5</span>
                  <span>6</span>
                  <span>7</span>
                  <span>8</span>
                  <span>9</span>
                </div>

                </li>



                <li class="drag-field-show">

                  <h3>mousedown</h3>
                  <p>перетаскивание</p>

                  <div class="drag-field">
                    <div class="drag-field__item"></div>
                    <div class="drag-field__point"></div>
                  </div>

                </li>



                <li class="key-down-up">

                  <h3>keydown / keyup</h3>
                  <p>события клавиатуры в консоли</p>
                  <p>автоповтор нажатой клавиши <code>event.repeat</code></p>
                  <p>автоповтор укажет в консоли true если вы зажали клавишу, при одиночном клике укажет
                    false</p>
                  <pre><code>
event.code  // вернет закодированную кнопку

event.key   // вернет значение 
</code></pre>

                  <div class="key-down-up__item">

                    <textarea class="key-down-up__textarea" maxlength="30" placeholder="введите что нибудь"></textarea>
                    <div class="key-down-up__counter">Осталось <span>30</span> символов</div>

                  </div>

                </li>


                <li class="loading">

                  <h3>loading</h3>

                  <p>События загрузки страницы:</p>


                  <ol>
                    <li>
                      <code>DOMContentLoaded - </code>
                      Браузер полностью загрузил html, было построено DOM дерево, но внешние ресурсы,
                      такие как imh
                      или стили, могут быть еще
                      не загружены
                    </li>
                    <li><code>load - </code>браузер загрузил html и внешние ресурсы (картинки, стили и
                      т.д.)</li>
                    <li><code>beforeunload / unload - </code>пользователь покидает страницу</li>
                  </ol>

                  <p><code>document.readyState - </code>состояние загрузки(можем отследить состояние
                    загрузки с
                    помощью этого свойства)</p>
                  <p>у <code>document.readyState</code> есть 3 возможных значения:</p>

                  <ul>
                    <li><code>loading - </code>документ загружается</li>
                    <li><code>interactive - </code>документ был полностью прочитан</li>
                    <li><code>complete - </code>документ был полностью прочитан и все ресурсы были тоже
                      загружены(картинки, стили и т.д.)</li>
                  </ul>

                  <img class="loading__img" src="../img/1.png" alt="">
                  <pre><code>
                          // DOMContentLoaded - срабатывает на объекте document
                          document.addEventListener("DOMContentLoaded", readyDom);
                          
                          // readyLoad - срабатывает на объекте window
                          window.addEventListener("load", readyLoad);
                          
                          function readyDom() {
                            const image = document.querySelector(".loading__img");
                            console.log(document.readyState);  //interactive
                            console.log("DOM загружен!");
                            console.log(image.offsetWidth);
                          }
                          
                          function readyLoad() {
                            const image = document.querySelector(".loading__img");
                            console.log(document.readyState); //complete
                            console.log("Страница загружен!");
                            console.log(image.offsetWidth);
                          }
                          </code></pre>


                  <h2>события ухода со страницы</h2>

                  <h3>beforeunload</h3>
                  <p>работает на объекте window</p>
                  <pre><code>
                          window.addEventListener("beforeunload", beforeUnload);
                          
                          function beforeUnload(event) {
                            event.preventDefault(); // отменение поведения как указано в стандарте
                            event.returnValue = ''; //хром требует установки возвратного значения
                          }
                          </code></pre>


                  <h3>unload</h3>
                  <p>работает на объекте window</p>
                  <p>unload - пользователь уже ушел со страницы но мы можем заставить браузер что то
                    выполнить в фоновом режиме</p>
                  <pre><code>
                          
                          window.addEventListener("unload", function (e) {
                              Отправка статистики в фоновом режиме и т.д.
                              navigator.sendBeacon(url, data)
                              https://w3c.github.io/beacon/.
                          })
                          </code></pre>


                </li>

                <li> <!--  Всплытие и погружение    ascent  -->

                  <h3>Всплытие и погружение</h3>

                  <p>В основном обработчики работают на всплытие а не на погружение</p>
                  <p>Когда на элементе происходит событие, обработчик сначала срабатывает на нём следом на его
                    родителе
                    затем выше и т.д., вверх по цепочке предков.</p>


                  <div class="ascent">

                    <h4>кликайте на блоки и смотрите консоль</h4>

                    <p>всплытие событий</p>

                    <div class="ascent-one">
                      <span>блок 1</span>
                      <div class="ascent-two">
                        <span>блок 2</span>
                        <div class="ascent-three">
                          <span>блок 3</span>
                        </div>
                      </div>
                    </div>

                    <h3>Ловим событие еще на погружении</h3>

                    <p><code>"capture": true</code></p>
                    <p>тут второй блок отлавливает событие ще на погружении и обрабатывает его, следом
                      обрабатываются
                      события на всплытии</p>

                    <div class="ascentListener-one">
                      <span>блок 1</span>
                      <div class="ascentListener-two">
                        <span>{"capture": true}</span>
                        <div class="ascentListener-three">
                          <span>блок 3</span>
                        </div>
                      </div>
                    </div>

                  </div>

                  <p>остановить всплытие можно методом <code>event.stopPropagation();</code></p>
                  <p>Все события которые всплыли бы(которые идут после этого вверх по цепочке) игнорируются и не
                    обрабатываются</p>





                  <div class="events__item">

                    <h3>Доступ к элементу через this</h3>
                    <p>Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором, как
                      говорят,
                      «висит» (т.е. назначен) обработчик.</p>

                    <button onclick="console.log(this.innerHTML)">Нажми меня</button>
                    <button onclick="console.log(this)">Нажми меня</button>


                  </div>



                </li>


                <li> <!-- addEventListener -->

                  <h2>addEventListener</h2>
                  <pre>


  <code>
const options = { 
  "capture": false,
  "once": false,
  "passive": true
}

element.addEventListener("click", testFunction, options);

function testFunction() {
  console.log(this); //выведет в консоль тип события
}
  </code>
</pre>

                  <dl>
                    <dt><code>"capture": true / false  -- </code>порядок обработки событий</dt>
                    <dd>
                      Фаза на которой должен сработать обработчик (всплытие или погружение). Ловит событие еще на
                      погружении
                      и можно обработать его прежде чем сработают обработчики на всплытие. если поставить на
                      средний элемент
                      true то сначала отработает он при погружении потом начнет всплывать и отработают другие
                      события, на
                      третьем и первом элементе
                    </dd>

                    <dt><code>"once": true / false -- </code>removeEventListener</dt>
                    <dd>
                      true удалит обработчик после выполнения (то же что и removeEventListener)
                    </dd>

                    <dt><code>"passive": true / false -- </code> не выполнит <code>preventDefaгlt();</code></dt>
                    <dd>
                      true указывает что обработчик не собирается
                      выполнять preventDefaгlt(отменяет действие браузера по умолчанию(смотрите в делегировании
                      собитий)).
                      Это значит что при скролле пальцем или подобное действие обработчик не будет отменять
                      действия
                      браузера по умолчанию, значит что при скролле пальцем задержек всяких не будет возникать и
                      скролл
                      будет плавным. true убирает ненужные задержки и браузер сразу начинает выполнять действия по
                      умолчанию
                      для некоторых браузеров эта опция уже включена по умолчанию(указана true) для таких событий
                      как:
                      <ul>
                        <li>
                          <code>addEventListener("touchstart",...)</code>
                        </li>
                        <li>
                          <code>addEventListener("touchmove",...)</code>
                        </li>
                      </ul>
                      т.е. если у вас есть отмена стандартных действий браузера по
                      умолчанию как в примере <a href="#events__item-link-cancle">отмены действий браузера</a> и
                      указан
                      <code>addEventListener(..., {"passive": true})</code> то действия по умолчанию выполнятся
                      проигнорировав вашу отмену
                    </dd>

                  </dl>

                </li>



                <li class="events__item delegate-event">

                  <h2>Делегирование событий (delegate-event).</h2>

                  <p>Если элементов достаточно много что бы не вешать обработчик на каждый из них(висящие на них
                    обработчики
                    могут не хило замедлить работу), можно повесить обработчик на их родителя, а функциональность
                    добавить
                    всем элементам через цикл.</p>

                  <button class="delegate-event__button">1</button>
                  <button class="delegate-event__button">2</button>
                  <button class="delegate-event__button">3</button>
                  <button class="delegate-event__button">4</button>



                </li>

                <li class="events__item">
                  <h4>меню на делегировании событий</h4>

                  <p>обработчик висит на document а не на самом меню</p>
                  <p>данное меню скрывается атрибутом hidden</p>

                  <nav class="delegate-event--menu">
                    <button type="button" class="delegate-event--menu--button">
                      <span>Открыть меню</span>
                      <span>Закрыть меню</span>
                    </button>
                    <ul hidden>
                      <li><a>пункт 1</a></li>
                      <li><a>пункт 2</a></li>
                      <li><a>пункт 3</a></li>
                      <li><a>пункт 4</a></li>
                    </ul>
                  </nav>
                </li>


                <li class="events__item"> <!-- Действия браузера по умолчанию и их отмена -->

                  <h3>Действия браузера по умолчанию и их отмена</h3>


                  <p>Многие события автоматически влекут за собой действие браузера по умолчанию, переходы по ссылкам
                    и т.д.
                  </p>

                  <ul class="link-cancle list-reset">

                    <li>
                      <a href="https://www.google.com" target="_blank" rel="noopener noreferrer">ссылка работает
                        как
                        указывает браузер(по умолчанию)</a>
                    </li>
                    <li>
                      <a class="link-cancle__two" href="https://www.google.com" target="_blank"
                        rel="noopener noreferrer">отменяем
                        работу по умолчанию
                        через addEventListener</a>
                    </li>
                    <li>
                      <a class="link-cancle__three" href="https://www.google.com" target="_blank"
                        rel="noopener noreferrer">отменяем
                        работу по умолчанию
                        через return</a>
                    </li>

                  </ul>
                  <pre><code>
let linkCancleTwo = document.querySelector(".link-cancle__two");
let linkCancleThree = document.querySelector(".link-cancle__three");

linkCancleTwo.addEventListener("click", function (event) {
  event.preventDefault(); //отменяет действие по умолчанию
});

//то же что и выше только если нельзя использовать addEventListene
linkCancleThree.onclick = function () {
  return false; 
}
</code></pre>


                </li>

                <li class="events__item"> <!-- onchange -->
                  <h3>onchange</h3>

                  <p>Событие onchange происходит при изменении значения элемента HTML. onchange происходит, когда
                    элемент
                    теряет фокус после изменения содержимого.</p>
                  <p>onchange можно использовать с разными элементами. Он срабатывает, когда пользователь переключает
                    чекбокс
                    или
                    радиокнопки.</p>
                  <pre>
  <code>
&lt;element onchange="myScript"&gt;

object.onchange = function(){myScript};

object.addEventListener("change", myScript);

  </code>
</pre>

                  <pre>
  <code>

    <a target="_blank" href="https://htmlacademy.ru/courses/351/run/13">Полное задание htmlacademy</a>

  select — это элемент с классом filter. 
  Найдём его, сохраним в переменную и добавим обработчик событий onchange.
  После этого скажем JavaScript выводить значение фильтра в консоль и 
  по очереди выберем несколько категорий из списка.


let articles = document.querySelectorAll('.news-block');   создаем артикль
let filter = document.querySelector('.filter');     селект

filter.onchange = function () { // onchange сработает при изменении в select
  for (let article of articles) {           //проверка, что выбранное значение фильтра строго не равно 'all'
    if (article.dataset.category !== filter.value && filter.value !== 'all') {                          
      article.classList.add('hidden');
    } else {
      article.classList.remove('hidden');
    }
  }
};



.hidden {
  display: none;
}
  </code>
</pre>


                  <p>onchange срабатывает, если значение поля ввода изменилось и пользователь закончил ввод.
                    Например, если
                    пользователь передвинул ползунок и отпустил его. Или ввёл что-то в текстовое поле и убрал из
                    него
                    курсор.
                  </p>
                  <p>oninput срабатывает на каждое изменение значения, независимо от того, завершил пользователь ввод
                    или
                    нет.
                    Например, он сработает на каждое изменение положения ползунка, даже если пользователь продолжает
                    его
                    двигать. И на
                    каждый новый символ в текстовом поле, даже если пользователь продолжает вводить текст.
                  </p>




                  <pre>
  <code>

&lt;label&gt;Цвет текста:
  &lt;select&gt; class="filter color-setting" name="font-color"&gt;
    &lt;option&gt; value="inherit" selected&gt;По умолчанию&lt;/option&gt;
    &lt;option&gt; value="purple"&gt;Пурпурный&lt;/option&gt;
    ...
  &lt;/select&gt;
&lt;/label&gt;

&lt;label&gt;Размер текста (&lt;output&gt;px class="pixels"&gt;14&lt;/output&gt;px)
  &lt;input class="size-setting" type="range" min="8" max="48" step="1" value="14"&gt;
&lt;/label&gt;

&lt;label&gt;Размер текста (&lt;output&gt;px class="pixels"&gt;14&lt;/output&gt;px)
  &lt;input class="size-setting" type="range" min="8" max="48" step="1" value="14"&gt;
&lt;/label&gt;


let longread = document.querySelector('.longread'); //блок с текстом
let colorSetting = document.querySelector('.color-setting');   
let sizeSetting = document.querySelector('.size-setting');         
let pixels = document.querySelector('.pixels');
let backgroundSetting = document.querySelector('.background-setting');

colorSetting.onchange = function () { 
  longread.style.color = colorSetting.value;
};

sizeSetting.oninput = function () {  // oninput подходит больше
  pixels.textContent = sizeSetting.value;
  longread.style.fontSize = sizeSetting.value + 'px';
};

backgroundSetting.onchange = function() {
  longread.style.backgroundColor = backgroundSetting.value;
}
  </code>
</pre>

                </li>

                <li class="show-password">
                  <h3>показать пароль</h3>

                  <pre>
  <code>
&lt;input class="password" type="password" placeholder="**********" required&gt;
&lt;input class="show-password" type="checkbox"&gt;


let password = document.querySelector('.password');
let showPassword = document.querySelector('.show-password');
let securityBar = document.querySelector('.security-bar');

showPassword.onchange = function () {
  if (showPassword.checked) {
     password.type = 'text';
  } else {                          //если чекбокс не checked то 
    password.type = 'password';       изменим type на pasword
  }                                  что бы снова скрыть пароль
};

      прогрессбар заполнения пароля
password.oninput = function () {
  
  let passLength = password.value.length;
  
  securityBar.style.width = passLength * 10 + '%';
  
  if (passLength <= 5) {
    securityBar.style.backgroundColor = 'red';
  } else if (passLength > 5 && passLength < 10) {
    securityBar.style.backgroundColor = 'gold';
  } else {
    securityBar.style.backgroundColor = 'green';
    }
};

тут * на 10 потому что минимальная длина пароля 10 символов.
умножайте на свое минимальное значение что бы полоса под инпутом 
заполнялась актуально
  </code>
</pre>


                </li>



                <li class="js-item"> <!-- выбор цвета по клику -->

                  <h3>выбор цвета по клику</h3>


                  <div class="controls">
                    <div class="container">
                      <select class="chosen-color" name="chosen-color">
                        <option value="black">Чёрный</option>
                        <option value="white">Белый</option>
                        <option value="grey">Серый</option>
                        <option value="pink">Розовый</option>
                        <option value="red">Красный</option>
                        <option value="darkorange">Оранжевый</option>
                        <option value="saddlebrown">Коричневый</option>
                        <option value="yellow">Золотой</option>
                        <option value="greenyellow">Салатовый</option>
                        <option value="forestgreen">Зелёный</option>
                        <option value="aquamarine">Аквамарин</option>
                        <option value="lightskyblue">Голубой</option>
                        <option value="lightsteelblue">Серо-голубой</option>
                        <option value="darkblue">Тёмно-синий</option>
                        <option value="indigo">Индиго</option>
                        <option value="mediumpurple">Фиолетовый</option>
                        <option value="purple">Пурпурный</option>
                      </select>
                      <input class="eraser visually-hidden" id="eraser-mode" type="checkbox" name="eraser">
                      <label class="eraser-label" for="eraser-mode">Ластик</label>
                    </div>
                  </div>

                  <div class="main">
                    <div class="canvas">
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                      <div class="pixel"></div>
                    </div>
                  </div>

                </li>


              </ul>






            </section>

          </section>

        </div>
      </div>
    </main>






    <footer class="page--footer">
      <div class="container">
        <div class="page--footer__inner">

          footer

        </div>
      </div>
    </footer>


  </div>

  <script src="../main.js"></script>
  <script src="../js/js.js"></script>
</body>

</html>